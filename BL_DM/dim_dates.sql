BEGIN;
CREATE SCHEMA IF NOT EXISTS BL_DM;
CREATE SCHEMA IF NOT EXISTS BL_CL;

DROP TABLE IF EXISTS BL_DM.DIM_DATES;
CREATE TABLE IF NOT EXISTS BL_DM.DIM_DATES
(
    DATE_ID             DATE,
    DAY_OF_WEEK_NUMBER  SMALLINT    NOT NULL,
    DAY_OF_WEEK_NAME    VARCHAR(10) NOT NULL,
    WEEKEND_FLAG        BOOLEAN     NOT NULL,
    ISO_WEEK_NUMBER     SMALLINT    NOT NULL,
    DAY_OF_MONTH_NUMBER SMALLINT    NOT NULL,
    MONTH_VALUE         SMALLINT    NOT NULL,
    MONTH_NAME          VARCHAR(10) NOT NULL,
    QUARTER_VALUE       SMALLINT    NOT NULL,
    QUARTER_NAME        VARCHAR(2)  NOT NULL,
    YEAR_VALUE          SMALLINT    NOT NULL,
    CONSTRAINT          PK_DIM_DATES_DATE_ID PRIMARY KEY (DATE_ID)
);

DROP TYPE IF EXISTS BL_DM.DATE_TYPE CASCADE;
CREATE TYPE BL_DM.DATE_TYPE AS
(
    DATE_ID             DATE,
    DAY_OF_WEEK_NUMBER  SMALLINT,
    DAY_OF_WEEK_NAME    VARCHAR(10),
    WEEKEND_FLAG        BOOLEAN,
    ISO_WEEK_NUMBER     SMALLINT,
    DAY_OF_MONTH_NUMBER SMALLINT,
    MONTH_VALUE         SMALLINT,
    MONTH_NAME          VARCHAR(10),
    QUARTER_VALUE       SMALLINT,
    QUARTER_NAME        VARCHAR(2),
    YEAR_VALUE          SMALLINT
);

DROP FUNCTION IF EXISTS BL_CL.FN_DM_LOAD_DATES;
CREATE OR REPLACE FUNCTION BL_CL.FN_DM_LOAD_DATES()
RETURNS SETOF BL_DM.DATE_TYPE
LANGUAGE PLPGSQL
AS $$
BEGIN
    RETURN QUERY
        SELECT  DATE_SEQ::DATE,
                EXTRACT(ISODOW FROM DATE_SEQ)::SMALLINT,
                TO_CHAR(DATE_SEQ, 'DAY')::VARCHAR(10),
                CASE WHEN EXTRACT(ISODOW FROM DATE_SEQ) IN (6, 7) THEN TRUE ELSE FALSE END,
                EXTRACT(WEEK FROM DATE_SEQ)::SMALLINT,
                EXTRACT(DAY FROM DATE_SEQ)::SMALLINT,
                EXTRACT(MONTH FROM DATE_SEQ)::SMALLINT,
                TO_CHAR(DATE_SEQ, 'MONTH')::VARCHAR(10),
                EXTRACT(QUARTER FROM DATE_SEQ)::SMALLINT,
                CONCAT('Q', TO_CHAR(DATE_SEQ, 'Q'))::VARCHAR(2),
                EXTRACT(YEAR FROM DATE_SEQ)::SMALLINT
        FROM    GENERATE_SERIES('2023-01-01'::DATE, '2024-12-31'::DATE, '1 DAY'::INTERVAL) AS DATE_SEQ;
END;
$$;

DROP PROCEDURE IF EXISTS BL_CL.SP_DM_LOAD_DIM_DATES;
CREATE OR REPLACE PROCEDURE BL_CL.SP_DM_LOAD_DIM_DATES()
LANGUAGE PLPGSQL
AS $$
DECLARE
    V_DATE          BL_DM.DATE_TYPE;
    V_CURSOR        REFCURSOR;
    V_INSERTED_ROWS BIGINT := 0;
    V_TOTAL_ROWS    BIGINT := 0;
    V_AFFECTED      BIGINT := 0;
BEGIN
    OPEN V_CURSOR FOR SELECT * FROM BL_CL.FN_DM_LOAD_DATES();
    
    LOOP
        FETCH V_CURSOR INTO V_DATE;
        EXIT WHEN NOT FOUND;
        
        INSERT INTO BL_DM.DIM_DATES (DATE_ID, DAY_OF_WEEK_NUMBER, DAY_OF_WEEK_NAME, WEEKEND_FLAG, ISO_WEEK_NUMBER, DAY_OF_MONTH_NUMBER, MONTH_VALUE, MONTH_NAME, QUARTER_VALUE, QUARTER_NAME, YEAR_VALUE)
        VALUES      (V_DATE.DATE_ID,
                    V_DATE.DAY_OF_WEEK_NUMBER,
                    V_DATE.DAY_OF_WEEK_NAME,
                    V_DATE.WEEKEND_FLAG,
                    V_DATE.ISO_WEEK_NUMBER,
                    V_DATE.DAY_OF_MONTH_NUMBER,
                    V_DATE.MONTH_VALUE,
                    V_DATE.MONTH_NAME,
                    V_DATE.QUARTER_VALUE,
                    V_DATE.QUARTER_NAME,
                    V_DATE.YEAR_VALUE)
        ON CONFLICT (DATE_ID) DO NOTHING;
        
        GET DIAGNOSTICS V_AFFECTED = ROW_COUNT;
        V_INSERTED_ROWS := V_INSERTED_ROWS + V_AFFECTED;
        V_TOTAL_ROWS := V_TOTAL_ROWS + 1;
    END LOOP;
    
    CLOSE V_CURSOR;
    CALL BL_CL.SP_MTA_UPDATE_LOAD('SP_DM_LOAD_DIM_DATES', 'BL_CL');
    CALL BL_CL.SP_MTA_INSERT_LOG('SP_DM_LOAD_DIM_DATES', 'BL_CL', 'LOAD PERFORMED SUCCESSFULLY', V_TOTAL_ROWS, V_INSERTED_ROWS, 0, 'N/A', 'N/A');
EXCEPTION WHEN OTHERS THEN
    BEGIN
        CLOSE V_CURSOR;
    EXCEPTION WHEN OTHERS THEN END;
    
    CALL BL_CL.SP_MTA_INSERT_LOG('SP_DM_LOAD_DIM_DATES', 'BL_CL', 'ERROR LOADING DIM_DATES', -1, -1, -1, UPPER(SQLSTATE), UPPER(SQLERRM));
    COMMIT;
    RAISE EXCEPTION 'ERROR LOADING DIM_DATES (%): %', UPPER(SQLSTATE), UPPER(SQLERRM);
END;
$$;
COMMIT;