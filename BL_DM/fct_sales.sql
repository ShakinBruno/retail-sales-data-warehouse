BEGIN;
CREATE SCHEMA IF NOT EXISTS BL_DM;
CREATE SCHEMA IF NOT EXISTS BL_CL;

DROP TABLE IF EXISTS BL_DM.FCT_SALES;
CREATE TABLE IF NOT EXISTS BL_DM.FCT_SALES
(
    SALE_SURR_ID            BIGINT,
    SALE_SRC_ID             VARCHAR(255)    NOT NULL,
    DATE_ID                 DATE            NOT NULL,
    TIME_ID                 SMALLINT        NOT NULL,
    CUSTOMER_SURR_ID        BIGINT          NOT NULL,
    PRODUCT_SURR_ID         BIGINT          NOT NULL,
    EMPLOYEE_SURR_ID        BIGINT          NOT NULL,
    LOCATION_SURR_ID        BIGINT          NOT NULL,
    PAYMENT_DETAIL_SURR_ID  BIGINT          NOT NULL,
    DEVICE_SURR_ID          BIGINT          NOT NULL,
    QUANTITY                SMALLINT,
    PRICE                   DECIMAL(10, 2),
    COST                    DECIMAL(10, 2),
    DISCOUNT                DECIMAL(3, 2),
    TOTAL_AMOUNT            DECIMAL(10, 2),
    SOURCE_SYSTEM           VARCHAR(255)    NOT NULL,
    SOURCE_ENTITY           VARCHAR(255)    NOT NULL,
    INSERT_DT               TIMESTAMP       NOT NULL,
    UPDATE_DT               TIMESTAMP       NOT NULL,
    CONSTRAINT              PK_FCT_SALES_SALE_SURR_ID_DATE_ID PRIMARY KEY (SALE_SURR_ID, DATE_ID),
    CONSTRAINT              FK_DIM_DATES_DATE_ID FOREIGN KEY (DATE_ID) REFERENCES BL_DM.DIM_DATES(DATE_ID),
    CONSTRAINT              FK_DIM_TIMES_TIME_ID FOREIGN KEY (TIME_ID) REFERENCES BL_DM.DIM_TIMES(TIME_ID),
    CONSTRAINT              FK_DIM_CUSTOMERS_CUSTOMER_SURR_ID FOREIGN KEY (CUSTOMER_SURR_ID) REFERENCES BL_DM.DIM_CUSTOMERS(CUSTOMER_SURR_ID),
    CONSTRAINT              FK_DIM_PRODUCTS_PRODUCT_SURR_ID FOREIGN KEY (PRODUCT_SURR_ID) REFERENCES BL_DM.DIM_PRODUCTS(PRODUCT_SURR_ID),
    CONSTRAINT              FK_DIM_EMPLOYEES_SCD_EMPLOYEE_SURR_ID FOREIGN KEY (EMPLOYEE_SURR_ID) REFERENCES BL_DM.DIM_EMPLOYEES_SCD(EMPLOYEE_SURR_ID),
    CONSTRAINT              FK_DIM_LOCATIONS_LOCATION_SURR_ID FOREIGN KEY (LOCATION_SURR_ID) REFERENCES BL_DM.DIM_LOCATIONS(LOCATION_SURR_ID),
    CONSTRAINT              FK_DIM_PAYMENT_DETAILS_PAYMENT_DETAIL_SURR_ID FOREIGN KEY (PAYMENT_DETAIL_SURR_ID) REFERENCES BL_DM.DIM_PAYMENT_DETAILS(PAYMENT_DETAIL_SURR_ID),
    CONSTRAINT              FK_DIM_DEVICES_DEVICE_SURR_ID FOREIGN KEY (DEVICE_SURR_ID) REFERENCES BL_DM.DIM_DEVICES(DEVICE_SURR_ID),
    CONSTRAINT              UNQ_FCT_SALES_SALE_SRC_ID_DATE_ID UNIQUE (SALE_SRC_ID, DATE_ID)
) PARTITION BY RANGE (DATE_ID);

DROP SEQUENCE IF EXISTS BL_DM.SEQ_SALE_SURR_ID;
CREATE SEQUENCE IF NOT EXISTS BL_DM.SEQ_SALE_SURR_ID START WITH 1 INCREMENT BY 1;

DROP PROCEDURE IF EXISTS BL_CL.SP_DM_ATTACH_FCT_SALES_PARTITIONS(DATE);
CREATE OR REPLACE PROCEDURE BL_CL.SP_DM_ATTACH_FCT_SALES_PARTITIONS(P_DATE_ID DATE)
LANGUAGE PLPGSQL
AS $PROC$
DECLARE
    V_PARTITION_NAME    TEXT;
    V_START_DATE        DATE;
    V_END_DATE          DATE;
    V_IS_PARTITION      BOOLEAN;
BEGIN
    V_START_DATE := DATE_TRUNC('MONTH', P_DATE_ID);
    V_END_DATE := V_START_DATE + INTERVAL '1 MONTH';
    V_PARTITION_NAME := CONCAT_WS('_p', 'fct_sales', TO_CHAR(V_START_DATE, 'YYYYMM'));
    
    SELECT      C.RELISPARTITION
    INTO        V_IS_PARTITION
    FROM        PG_CLASS AS C
    INNER JOIN  PG_NAMESPACE AS N ON N.OID = C.RELNAMESPACE
    WHERE       UPPER(C.RELNAME) = UPPER(V_PARTITION_NAME) AND UPPER(N.NSPNAME) = 'BL_DM';
    
    IF V_IS_PARTITION IS NULL THEN
        EXECUTE FORMAT($$CREATE TABLE IF NOT EXISTS BL_DM.%I PARTITION OF BL_DM.FCT_SALES FOR VALUES FROM (%L) TO (%L)$$, V_PARTITION_NAME, V_START_DATE, V_END_DATE);
    ELSIF V_IS_PARTITION = FALSE THEN
        EXECUTE FORMAT($$ALTER TABLE BL_DM.FCT_SALES ATTACH PARTITION BL_DM.%I FOR VALUES FROM (%L) TO (%L)$$, V_PARTITION_NAME, V_START_DATE, V_END_DATE);
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE EXCEPTION 'ERROR PARTITIONING FCT_SALES (%): %', UPPER(SQLSTATE), UPPER(SQLERRM);
END;
$PROC$;

DROP PROCEDURE IF EXISTS BL_CL.SP_DM_DETACH_FCT_SALES_PARTITIONS(DATE, SMALLINT);
CREATE OR REPLACE PROCEDURE BL_CL.SP_DM_DETACH_FCT_SALES_PARTITIONS(P_DATE_ID DATE, P_ROLLING_WINDOW_MONTHS SMALLINT DEFAULT 3)
LANGUAGE PLPGSQL
AS $PROC$
DECLARE
    V_PARTITION_START_DATE  DATE;
    V_CUTOFF_DATE           DATE;
    V_REC                   RECORD;
BEGIN    
    FOR V_REC IN (  SELECT      C.RELNAME
                    FROM        PG_CLASS        AS C
                    INNER JOIN  PG_NAMESPACE    AS N ON C.RELNAMESPACE = N.OID 
                    INNER JOIN  PG_INHERITS     AS I ON C.OID = I.INHRELID
                    INNER JOIN  PG_CLASS        AS P ON P.OID = I.INHPARENT
                    WHERE       UPPER(P.RELNAME) = 'FCT_SALES' AND UPPER(N.NSPNAME) = 'BL_DM' AND C.RELISPARTITION = TRUE) LOOP

            V_PARTITION_START_DATE := TO_DATE(SPLIT_PART(V_REC.RELNAME, '_p', 2), 'YYYYMM');
            V_CUTOFF_DATE := P_DATE_ID - CONCAT(P_ROLLING_WINDOW_MONTHS, ' MONTHS')::INTERVAL;
                
            IF V_PARTITION_START_DATE < V_CUTOFF_DATE THEN
                EXECUTE FORMAT($$ALTER TABLE BL_DM.FCT_SALES DETACH PARTITION BL_DM.%I$$, V_REC.RELNAME);
            END IF;
    END LOOP;
EXCEPTION WHEN OTHERS THEN
    RAISE EXCEPTION 'ERROR PARTITIONING FCT_SALES (%): %', UPPER(SQLSTATE), UPPER(SQLERRM);
END;
$PROC$;

DROP FUNCTION IF EXISTS BL_CL.FN_DM_TRANSFORM_SALES;
CREATE OR REPLACE FUNCTION BL_CL.FN_DM_TRANSFORM_SALES()
RETURNS TABLE
(
    SALE_ID             VARCHAR(255),
    DATE_ID             DATE,
    TIME_ID             SMALLINT,
    CUSTOMER_ID         BIGINT,
    PRODUCT_ID          BIGINT,
    EMPLOYEE_ID         BIGINT,
    LOCATION_ID         BIGINT,
    PAYMENT_DETAIL_ID   BIGINT,
    DEVICE_ID           BIGINT,
    QUANTITY            SMALLINT,
    PRICE               DECIMAL(10, 2),
    COST                DECIMAL(10, 2),
    DISCOUNT            DECIMAL(3, 2),
    TOTAL_AMOUNT        DECIMAL(10, 2),
    SOURCE_SYSTEM       VARCHAR(255),
    SOURCE_ENTITY       VARCHAR(255)
)
LANGUAGE PLPGSQL
AS $$
DECLARE
    V_LAST_LOAD_DT TIMESTAMP;
BEGIN
    SELECT  LAST_LOAD_DT
    INTO    V_LAST_LOAD_DT
    FROM    BL_CL.MTA_LOADS
    WHERE   PROCEDURE_NAME = 'SP_DM_LOAD_FCT_SALES' AND PROCEDURE_SCHEMA = 'BL_CL';
    
    IF V_LAST_LOAD_DT IS NULL THEN
        V_LAST_LOAD_DT := '1900-01-01 00:00:00';
    END IF;  

    RETURN QUERY
        SELECT          CE.SALE_ID::VARCHAR,
                        CE.EVENT_DT::DATE,
                        (EXTRACT(HOUR FROM CE.EVENT_DT) * 60 + EXTRACT(MINUTE FROM CE.EVENT_DT))::SMALLINT,
                        COALESCE(CUS.CUSTOMER_SURR_ID, -1),
                        COALESCE(PRO.PRODUCT_SURR_ID, -1),
                        COALESCE(EMP.EMPLOYEE_SURR_ID, -1),
                        COALESCE(LOC.LOCATION_SURR_ID, -1),
                        COALESCE(PAY.PAYMENT_DETAIL_SURR_ID, -1),
                        COALESCE(DEV.DEVICE_SURR_ID, -1),
                        CE.QUANTITY,
                        CE.PRICE,
                        (CE.QUANTITY * CE.PRICE)::DECIMAL,
                        CE.DISCOUNT,
                        CE.TOTAL_AMOUNT,
                        'BL_3NF'::VARCHAR,
                        'CE_SALES'::VARCHAR
        FROM            BL_3NF.CE_SALES             AS CE
        LEFT OUTER JOIN BL_DM.DIM_CUSTOMERS         AS CUS ON   CE.CUSTOMER_ID::VARCHAR = CUS.CUSTOMER_SRC_ID
        LEFT OUTER JOIN BL_DM.DIM_PRODUCTS          AS PRO ON   CE.PRODUCT_ID::VARCHAR = PRO.PRODUCT_SRC_ID
        LEFT OUTER JOIN BL_DM.DIM_EMPLOYEES_SCD     AS EMP ON   CE.EMPLOYEE_ID::VARCHAR = EMP.EMPLOYEE_SRC_ID AND
                                                                CE.EVENT_DT BETWEEN EMP.START_DT AND EMP.END_DT
        LEFT OUTER JOIN BL_DM.DIM_LOCATIONS         AS LOC ON   EMP.LOCATION_ID::VARCHAR = LOC.LOCATION_SRC_ID
        LEFT OUTER JOIN BL_DM.DIM_PAYMENT_DETAILS   AS PAY ON   CE.PAYMENT_DETAIL_ID::VARCHAR = PAY.PAYMENT_DETAIL_SRC_ID
        LEFT OUTER JOIN BL_DM.DIM_DEVICES           AS DEV ON   CE.DEVICE_ID::VARCHAR = DEV.DEVICE_SRC_ID
        WHERE           CE.UPDATE_DT > V_LAST_LOAD_DT;
        
END;
$$;

DROP PROCEDURE IF EXISTS BL_CL.SP_DM_LOAD_FCT_SALES;
CREATE OR REPLACE PROCEDURE BL_CL.SP_DM_LOAD_FCT_SALES()
LANGUAGE PLPGSQL
AS $PROC$
DECLARE
    V_DATE          DATE;
    V_DATES         DATE[];
    V_INSERTED_ROWS BIGINT := 0;
    V_UPDATED_ROWS  BIGINT := 0;
    V_TOTAL_ROWS    BIGINT := 0;
BEGIN
    SELECT  COUNT(*)
    INTO    V_TOTAL_ROWS
    FROM    BL_CL.FN_DM_TRANSFORM_SALES();
    
    WITH INSERTED_RECORDS AS
    (
        SELECT          SOURCE.SALE_ID
        FROM            BL_CL.FN_DM_TRANSFORM_SALES()   AS SOURCE
        LEFT OUTER JOIN BL_DM.FCT_SALES                 AS TARGET ON SOURCE.SALE_ID::VARCHAR = TARGET.SALE_SRC_ID
        WHERE           TARGET.SALE_SRC_ID IS NULL
    )
    SELECT  COUNT(*)
    INTO    V_INSERTED_ROWS
    FROM    INSERTED_RECORDS;
    
    WITH UPDATED_RECORDS AS
    (
        SELECT      SOURCE.SALE_ID
        FROM        BL_CL.FN_DM_TRANSFORM_SALES()   AS SOURCE
        INNER JOIN  BL_DM.FCT_SALES                 AS TARGET ON SOURCE.SALE_ID::VARCHAR = TARGET.SALE_SRC_ID
        WHERE       TARGET.CUSTOMER_SURR_ID != SOURCE.CUSTOMER_ID OR
                    TARGET.PRODUCT_SURR_ID != SOURCE.PRODUCT_ID OR
                    TARGET.EMPLOYEE_SURR_ID != SOURCE.EMPLOYEE_ID OR
                    TARGET.LOCATION_SURR_ID != SOURCE.LOCATION_ID OR
                    TARGET.PAYMENT_DETAIL_SURR_ID != SOURCE.PAYMENT_DETAIL_ID OR
                    TARGET.DEVICE_SURR_ID != SOURCE.DEVICE_ID OR
                    TARGET.QUANTITY != SOURCE.QUANTITY OR
                    TARGET.PRICE != SOURCE.PRICE OR
                    TARGET.COST != SOURCE.COST OR
                    TARGET.DISCOUNT != SOURCE.DISCOUNT OR
                    TARGET.TOTAL_AMOUNT != SOURCE.TOTAL_AMOUNT
    )
    SELECT  COUNT(*)
    INTO    V_UPDATED_ROWS
    FROM    UPDATED_RECORDS;
    
    SELECT  ARRAY_AGG(DISTINCT DATE_ID) 
    INTO    V_DATES 
    FROM    BL_CL.FN_DM_TRANSFORM_SALES();
    
    IF V_DATES IS NOT NULL THEN
        FOREACH V_DATE IN ARRAY V_DATES LOOP
            CALL BL_CL.SP_DM_ATTACH_FCT_SALES_PARTITIONS(V_DATE);
        END LOOP;
    END IF;
    
    MERGE INTO  BL_DM.FCT_SALES                                 AS TARGET
    USING       (SELECT * FROM BL_CL.FN_DM_TRANSFORM_SALES())   AS SOURCE
    ON          (SOURCE.SALE_ID = TARGET.SALE_SRC_ID)
    WHEN MATCHED AND (
        TARGET.CUSTOMER_SURR_ID != SOURCE.CUSTOMER_ID OR
        TARGET.PRODUCT_SURR_ID != SOURCE.PRODUCT_ID OR
        TARGET.EMPLOYEE_SURR_ID != SOURCE.EMPLOYEE_ID OR
        TARGET.LOCATION_SURR_ID != SOURCE.LOCATION_ID OR
        TARGET.PAYMENT_DETAIL_SURR_ID != SOURCE.PAYMENT_DETAIL_ID OR
        TARGET.DEVICE_SURR_ID != SOURCE.DEVICE_ID OR
        TARGET.QUANTITY != SOURCE.QUANTITY OR
        TARGET.PRICE != SOURCE.PRICE OR
        TARGET.COST != SOURCE.COST OR
        TARGET.DISCOUNT != SOURCE.DISCOUNT OR
        TARGET.TOTAL_AMOUNT != SOURCE.TOTAL_AMOUNT
    ) THEN
        UPDATE
        SET     CUSTOMER_SURR_ID = SOURCE.CUSTOMER_ID,
                PRODUCT_SURR_ID = SOURCE.PRODUCT_ID,
                EMPLOYEE_SURR_ID = SOURCE.EMPLOYEE_ID,
                LOCATION_SURR_ID = SOURCE.LOCATION_ID,
                PAYMENT_DETAIL_SURR_ID = SOURCE.PAYMENT_DETAIL_ID,
                DEVICE_SURR_ID = SOURCE.DEVICE_ID,
                QUANTITY = SOURCE.QUANTITY,
                PRICE = SOURCE.PRICE,
                COST = SOURCE.COST,
                DISCOUNT = SOURCE.DISCOUNT,
                TOTAL_AMOUNT = SOURCE.TOTAL_AMOUNT,
                UPDATE_DT = CURRENT_TIMESTAMP
    WHEN NOT MATCHED THEN
        INSERT (SALE_SURR_ID, SALE_SRC_ID, DATE_ID, TIME_ID, CUSTOMER_SURR_ID, PRODUCT_SURR_ID, EMPLOYEE_SURR_ID, LOCATION_SURR_ID, PAYMENT_DETAIL_SURR_ID, DEVICE_SURR_ID, QUANTITY, PRICE, COST, DISCOUNT, TOTAL_AMOUNT, SOURCE_SYSTEM, SOURCE_ENTITY, INSERT_DT, UPDATE_DT)
        VALUES (NEXTVAL('BL_DM.SEQ_SALE_SURR_ID'),
                SOURCE.SALE_ID,
                SOURCE.DATE_ID,
                SOURCE.TIME_ID, 
                SOURCE.CUSTOMER_ID,
                SOURCE.PRODUCT_ID,
                SOURCE.EMPLOYEE_ID,
                SOURCE.LOCATION_ID, 
                SOURCE.PAYMENT_DETAIL_ID,
                SOURCE.DEVICE_ID,
                SOURCE.QUANTITY,
                SOURCE.PRICE, 
                SOURCE.COST,
                SOURCE.DISCOUNT,
                SOURCE.TOTAL_AMOUNT,
                SOURCE.SOURCE_SYSTEM,
                SOURCE.SOURCE_ENTITY, 
                CURRENT_TIMESTAMP,
                CURRENT_TIMESTAMP);

    SELECT  COALESCE(MAX(DATE_ID), '1900-01-01')
    INTO    V_DATE
    FROM    BL_DM.FCT_SALES;
    
    CALL BL_CL.SP_DM_DETACH_FCT_SALES_PARTITIONS(V_DATE);
    
    CALL BL_CL.SP_MTA_UPDATE_LOAD('SP_DM_LOAD_FCT_SALES', 'BL_CL');
    CALL BL_CL.SP_MTA_INSERT_LOG('SP_DM_LOAD_FCT_SALES', 'BL_CL', 'LOAD PERFORMED SUCCESSFULLY', V_TOTAL_ROWS, V_INSERTED_ROWS, V_UPDATED_ROWS, 'N/A', 'N/A');
EXCEPTION WHEN OTHERS THEN
    CALL BL_CL.SP_MTA_INSERT_LOG('SP_DM_LOAD_FCT_SALES', 'BL_CL', 'ERROR LOADING FCT_SALES', -1, -1, -1, UPPER(SQLSTATE), UPPER(SQLERRM));
    COMMIT;
    RAISE EXCEPTION 'ERROR LOADING FCT_SALES (%): %', UPPER(SQLSTATE), UPPER(SQLERRM);
END;
$PROC$;
COMMIT;